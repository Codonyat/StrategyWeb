import { useState } from 'react';
import { CONTRACT_CONFIG } from '../config/contract';
import './HowItWorks.css';

export default function HowItWorks() {
  const [openQuestion, setOpenQuestion] = useState(null);

  const toggleQuestion = (questionId) => {
    setOpenQuestion(openQuestion === questionId ? null : questionId);
  };

  const faqCategories = [
    {
      category: 'Basics',
      faqs: [
        {
          id: 'what-is-monstr',
          question: 'What is MONSTR?',
          answer: (
            <>
              <p>
                <strong>MONSTR is a strategy coin backed 100% by MON.</strong> You can always burn MONSTR to withdraw MON from the backing pool, and protocol fees create an up-only backing ratio over time.
              </p>
            </>
          ),
        },
        {
          id: 'when-mint',
          question: 'When can I mint tokens?',
          answer: (
            <>
              <p>
                <strong>Minting is open for the first 3 days after deployment.</strong> During this minting period 1 MON mints 1 MONSTR, before any fees or premiums. After the minting period ends you can only acquire MONSTR on the market.
              </p>
            </>
          ),
        },
        {
          id: 'redeem-anytime',
          question: 'Can I redeem my tokens anytime?',
          answer: (
            <>
              <p>
                <strong>Yes.</strong> You can burn MONSTR at any time to redeem MON from the backing pool at the current backing ratio. A 1% protocol fee is applied on redemptions.
              </p>
            </>
          ),
        },
        {
          id: 'risky',
          question: 'Is MONSTR risky?',
          answer: (
            <>
              <p>
                <strong>MONSTR is an experimental protocol.</strong> Like all DeFi applications, it carries risks including smart contract vulnerabilities and exposure to MON price volatility. The backing mechanism ensures you can always redeem at the current backing ratio, so market prices should track backing through arbitrage. Always do your own research before participating.
              </p>
            </>
          ),
        },
      ],
    },
    {
      category: 'Mechanics',
      faqs: [
        {
          id: 'backing-works',
          question: 'How does the backing mechanism work?',
          answer: (
            <>
              <p>
                <strong>All MON sent into the protocol</strong> (minting, fees, and auction proceeds) stays in the reserve. MONSTR supply can go down over time when tokens are burned. Because the pool can grow while supply shrinks, the backing per MONSTR tends to increase as long as the protocol collects more fees than it pays out.
              </p>
            </>
          ),
        },
        {
          id: 'fees',
          question: 'What are the fees?',
          answer: (
            <>
              <p>
                <strong>There is a 1% fee on mint, burn, and transfers of MONSTR.</strong> These fees are routed into the protocol and split between the lottery pool and the auction pool.
              </p>
            </>
          ),
        },
        {
          id: 'backing-vs-price',
          question: 'What is the difference between backing ratio and exchange price?',
          answer: (
            <>
              <p>
                <strong>The backing ratio</strong> tells you how much MON sits behind each MONSTR in the reserve. <strong>The exchange price</strong> is whatever the token trades for on the market. Since anyone can redeem MONSTR for backing at any time, arbitrageurs will buy below backing and redeem for profit, creating a price floor. In practice, MONSTR should trade at or above backing.
              </p>
            </>
          ),
        },
        {
          id: 'lottery',
          question: 'How does the lottery work?',
          answer: (
            <>
              <p>
                <strong>Each day the protocol snapshots MONSTR holder balances.</strong> Using on-chain randomness, one holder is chosen at random, weighted by their balance. The winner can claim that day's lottery pool, which is funded by a share of protocol fees.
              </p>
            </>
          ),
        },
        {
          id: 'auctions',
          question: 'How do the daily auctions work?',
          answer: (
            <>
              <p>
                <strong>Another share of protocol fees is converted to MONSTR and auctioned once per day.</strong> Users bid with MON or WMON. At the end of the day the highest bid wins the pool of MONSTR. Losing bidders keep their MON.
              </p>
            </>
          ),
        },
        {
          id: 'unclaimed-prizes',
          question: 'What happens to unclaimed prizes?',
          answer: (
            <>
              <p>
                <strong>Lottery and auction prizes can be claimed for 7 days.</strong> After that window closes unclaimed prizes are sent to the treasury address defined in the contract.
              </p>
            </>
          ),
        },
        {
          id: 'auction-bidding',
          question: 'Can I bid with MON or WMON?',
          answer: (
            <>
              <p>
                <strong>You can bid with either MON or WMON.</strong> The contract accepts both. WMON support allows the contract to pull bids safely with <code>transferFrom</code> and prevents certain denial-of-service issues. MON support provides direct convenience for bidders.
              </p>
            </>
          ),
        },
      ],
    },
    {
      category: 'Timing and randomness',
      faqs: [
        {
          id: 'pseudo-day',
          question: 'What is a pseudo-day and why 25 hours?',
          answer: (
            <>
              <p>
                <strong>The protocol uses 25-hour pseudo-days instead of 24 hours.</strong> That slowly rotates the time of day when lotteries and auctions roll over so no single timezone always gets the most convenient reset time.
              </p>
            </>
          ),
        },
        {
          id: 'winner-selection',
          question: 'How are lottery winners selected?',
          answer: (
            <>
              <p>
                <strong>The contract uses a data structure that tracks holder balances</strong> and picks a random position using the prevrandao value from the block. This lets it select a winner weighted by balance without iterating over all holders.
              </p>
            </>
          ),
        },
      ],
    },
    {
      category: 'Operations and contracts',
      faqs: [
        {
          id: 'treasury',
          question: 'What is the treasury address?',
          answer: (
            <>
              <p>
                <strong>The treasury address is a hard-coded address</strong> that receives unclaimed prizes and other protocol funds. You can view it in the contract under <code>BENEFICIARIES</code>.
              </p>
              <p>
                Treasury: <code>{CONTRACT_CONFIG.treasury}</code>
              </p>
            </>
          ),
        },
        {
          id: 'contract-address',
          question: 'What is the contract address?',
          answer: (
            <>
              <p>
                <strong>The strategy contract address is shown in the footer and on the FAQ page.</strong> You can click it to open the contract on the block explorer and verify the source code.
              </p>
              <p>
                Contract: <code>{CONTRACT_CONFIG.address}</code>
              </p>
              <p>
                Network: <strong>{CONTRACT_CONFIG.chainName}</strong>
              </p>
            </>
          ),
        },
        {
          id: 'audited',
          question: 'Has the contract been audited?',
          answer: (
            <>
              <p>
                <strong>The MONSTR contract has been audited for Ethereum and then adapted for Monad testnet.</strong> Audits reduce but do not remove risk. Always review the code and audit reports yourself.
              </p>
            </>
          ),
        },
        {
          id: 'stake-lock',
          question: 'Do I need to stake or lock MONSTR to enter the lottery?',
          answer: (
            <>
              <p>
                <strong>No.</strong> You stay entered in the daily lottery as long as you hold MONSTR in your wallet at the time of the daily snapshot. Note that only regular wallets participate, smart contracts are excluded from lottery draws.
              </p>
            </>
          ),
        },
        {
          id: 'wallets-networks',
          question: 'What wallets and networks are supported?',
          answer: (
            <>
              <p>
                <strong>MONSTR currently runs on {CONTRACT_CONFIG.chainName}</strong> and supports any wallet that can connect to EVM-compatible networks, such as MetaMask or Rabby.
              </p>
            </>
          ),
        },
      ],
    },
  ];

  return (
    <div className="how-it-works-page">
      <div className="page-container">
        {/* Intro Section */}
        <section className="intro-section">
          <h1 className="page-title">Frequently Asked Questions</h1>
          <p className="intro-text">
            Everything you need to know about MONSTR, the Strategy Coin backed by MON.
          </p>
        </section>

        {/* FAQ List */}
        <section className="faq-sections">
          {faqCategories.map((category) => (
            <div key={category.category} className="faq-category">
              <h2 className="category-label">{category.category}</h2>
              <div className="collapsible-sections">
                {category.faqs.map((faq) => (
                  <div key={faq.id} className="collapsible-section">
                    <button
                      className={`section-header ${openQuestion === faq.id ? 'open' : ''}`}
                      onClick={() => toggleQuestion(faq.id)}
                    >
                      <span className="section-title">{faq.question}</span>
                      <span className="section-icon">{openQuestion === faq.id ? 'âˆ’' : '+'}</span>
                    </button>
                    {openQuestion === faq.id && (
                      <div className="section-body">
                        <div className="section-content">{faq.answer}</div>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          ))}
        </section>
      </div>
    </div>
  );
}
